<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Rubin LC Browser — katalog</title>
  <style>
    body{font-family:Inter,system-ui,Arial;background:#f8fafc;color:#0f172a;margin:0;padding:18px}
    .wrap{max-width:1100px;margin:0 auto}
    header h1{margin:0 0 12px;padding-bottom:8px;border-bottom:1px solid #e6edf3;font-size:20px}
    .panel{background:#fff;padding:12px;border-radius:10px;box-shadow:0 1px 0 rgba(16,24,40,0.03);margin-bottom:12px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{background:#2563eb;color:white;border:0;padding:8px 10px;border-radius:8px;cursor:pointer}
    .btn-ghost{background:transparent;color:#111;border:1px solid #e6edf3;padding:7px 10px;border-radius:8px}
    #catalog { max-height:420px; overflow:auto; margin-top:8px }
    .obj{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;border:1px solid #eef2f6;margin-bottom:8px}
    .thumb{width:96px;height:64px;background:#f3f4f6;display:flex;align-items:center;justify-content:center;font-size:11px;color:#94a3b8;overflow:hidden}
    canvas{width:100%;height:280px;border-radius:8px;background:white}
    .muted{color:#6b7280;font-size:13px}
    .folder{border:1px dashed #dbeafe;padding:8px;border-radius:8px;margin-bottom:8px}
    input, textarea, select{padding:6px 8px;border-radius:8px;border:1px solid #e6edf3}
  </style>
</head>
<body>
  <div class="wrap">
    <header><h1>Rubin Lightcurve Browser — katalog (stronicowany)</h1></header>

    <section class="panel">
      <div class="row">
        <div class="muted">Use proxy URL:</div>
        <input id="proxyUrl" placeholder="https://my-proxy.vercel.app/api/adql" style="flex:1" />
        <button id="setProxy">Set</button>
        <button id="toggleUseProxy" class="btn-ghost">Use proxy: OFF</button>
        <button id="loadCatalog" style="margin-left:auto">Load catalog page</button>
      </div>
      <div style="margin-top:8px" class="muted">
        Instrukcja: ustaw proxy (jeśli masz), kliknij "Set", potem "Use proxy" → ON, następnie "Load catalog page".
        Domyślnie używa mock-danych — po ustawieniu proxy zacznie pobierać z TAP.
      </div>
      <div style="margin-top:10px" class="row">
        <label>Page size <input id="pageSize" type="number" value="100" style="width:90px" /></label>
        <label>Offset <input id="offset" type="number" value="0" style="width:120px" /></label>
        <button id="nextPage" class="btn-ghost">Load next page (offset += pageSize)</button>
        <button id="prevPage" class="btn-ghost">Prev page</button>
      </div>
    </section>

    <section style="display:flex;gap:12px">
      <div style="flex:2">
        <div class="panel">
          <div class="muted">Podgląd krzywej (kliknij obiekt z listy po prawej)</div>
          <canvas id="lcCanvas"></canvas>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="savePng">Save PNG</button>
            <button id="addToFolder" class="btn-ghost">Dodaj do folderu</button>
            <button id="prevObj" class="btn-ghost">Prev obj</button>
            <button id="nextObj" class="btn-ghost">Next obj</button>
            <div style="margin-left:auto">
              <button id="exportCsv" class="btn-ghost">Eksport CSV</button>
            </div>
          </div>

          <div style="margin-top:12px">
            <div class="muted">Adnotacje / opis</div>
            <input id="name" placeholder="Nazwa" style="width:100%;margin-top:6px" />
            <input id="category" placeholder="Kategoria" style="width:100%;margin-top:6px" />
            <textarea id="note" placeholder="Opis / notatki" rows="3" style="width:100%;margin-top:6px"></textarea>
            <div style="display:flex;gap:8px;margin-top:6px">
              <button id="saveAnnotation">Zapisz adnotację</button>
              <button id="removeFromFolder" class="btn-ghost">Usuń z folderu</button>
            </div>
          </div>
        </div>
        <div class="panel">
          <div class="muted">Foldery / kolekcje</div>
          <div id="folders"></div>
          <div style="margin-top:8px;display:flex;gap:8px">
            <input id="newFolderName" placeholder="Nowy folder" />
            <button id="createFolder" class="btn-ghost">Utwórz</button>
          </div>
        </div>
      </div>

      <div style="flex:1">
        <div class="panel">
          <div class="muted">Katalog obiektów (strona)</div>
          <div id="catalog"></div>
        </div>
      </div>
    </section>

    <footer style="margin-top:12px" class="muted">Adnotacje, foldery i PNG przechowywane lokalnie (localStorage). Aby pobrać rzeczywiste dane LSST musisz ustawić proxy i włączyć "Use proxy".</footer>
  </div>

<script>
/* ---------------- Konfiguracja i stan ---------------- */
let ADQL_POST_URL = '/api/adql';     // zmień przez window.setAdqlUrl(...) lub pole input + Set
let USE_PROXY = false;
const TABLE = 'dp02_dc2_catalogs.Object'; // tabela z listą obiektów — możesz zmienić
// Czy SPRAWDŹ: w DP vs DR nazwy tabel mogą być inne; jeśli nie działa -> podaj właściwą nazwę tabeli.
let pageSize = 100;
let offset = 0;

let catalog = []; // lista obiektów (dla aktualnej strony): {objectId, ra, dec}
let currentIndex = -1; // index w catalog
let objectsCache = {}; // cache pomiarów po objectId -> {measurements, png, annotations}

/* ---------- Helpers: ADQL ---------- */
function buildCatalogAdql(limit, offsetVal){
  // Pobierz podstawowe informacje o obiektach; dopasuj kolumny jeśli trzeba
  return `SELECT objectId, ra, dec FROM ${TABLE} ORDER BY objectId LIMIT ${limit} OFFSET ${offsetVal}`;
}
function buildMeasurementsAdql(objectId){
  // Tabela z pomiarami (dostosuj do Twojego TAP: ForcedSource/Source/ForcedSource...)
  // Uwaga: objectId może być liczbowy lub string - cytujemy jako literal jeśli zawiera litery.
  const oid = String(objectId);
  // jeżeli objectId jest liczbowe, unikamy cytowania; tutaj robimy bezpieczną wersję:
  const where = isFinite(Number(oid)) ? `objectId = ${oid}` : `objectId = '${oid.replace(/'/g,"''")}'`;
  // adjust measurements table name if needed:
  const MEAS_TABLE = 'dp02_dc2_catalogs.ForcedSource';
  return `SELECT mjd, psfFluxMag as mag, psfFluxMagErr as magerr, filter FROM ${MEAS_TABLE} WHERE ${where} ORDER BY mjd`;
}

/* ---------- POST ADQL via proxy (proxy musi zwracać JSON) ---------- */
async function postAdql(adql){
  if (!USE_PROXY) throw new Error('Proxy not enabled. Set Use proxy = ON and set ADQL_POST_URL.');
  const resp = await fetch(ADQL_POST_URL, {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ adql })
  });
  if (!resp.ok) {
    const txt = await resp.text();
    throw new Error('HTTP ' + resp.status + ' ' + resp.statusText + ' — ' + txt.slice(0,200));
  }
  const txt = await resp.text();
  try { return JSON.parse(txt); } catch(e) { throw new Error('Invalid JSON from proxy: ' + e.message + ' -> ' + txt.slice(0,200)); }
}

/* ---------- Parse common TAP JSON shapes ---------- */
function parseTapJson(data){
  if (Array.isArray(data)) return data;
  if (data.rows && Array.isArray(data.rows)) return data.rows;
  if (data.data && data.fields) {
    const names = data.fields.map(f=>f.name);
    return data.data.map(r => { const obj = {}; for(let i=0;i<names.length;i++) obj[names[i]] = r[i]; return obj; });
  }
  if (Array.isArray(data.result)) return data.result;
  if (Array.isArray(data.data)) return data.data;
  return [];
}

/* ---------- UI: catalog rendering ---------- */
const catalogDiv = document.getElementById('catalog');
const lcCanvas = document.getElementById('lcCanvas');
const pageSizeInput = document.getElementById('pageSize');
const offsetInput = document.getElementById('offset');

function renderCatalog(){
  catalogDiv.innerHTML = '';
  catalog.forEach((o, idx) => {
    const el = document.createElement('div'); el.className='obj';
    const thumb = document.createElement('div'); thumb.className='thumb';
    const cached = objectsCache[o.objectId];
    if (cached && cached.png){ const img = document.createElement('img'); img.src = cached.png; img.style.width='100%'; thumb.innerHTML=''; thumb.appendChild(img); } else thumb.textContent = 'no png';
    el.appendChild(thumb);
    const info = document.createElement('div'); info.style.flex='1';
    const title = document.createElement('div'); title.textContent = o.objectId; title.style.fontWeight='600';
    const coords = document.createElement('div'); coords.className='muted'; coords.textContent = `${o.ra?.toFixed(5)||''}, ${o.dec?.toFixed(5)||''}`;
    info.appendChild(title); info.appendChild(coords);
    el.appendChild(info);
    const btn = document.createElement('button'); btn.textContent='Open'; btn.onclick = ()=> openObject(idx);
    el.appendChild(btn);
    catalogDiv.appendChild(el);
  });
}

/* ---------- Open object: load measurements (via proxy) or from cache ---------- */
async function openObject(idx){
  if (idx<0 || idx>=catalog.length) return;
  currentIndex = idx;
  const obj = catalog[idx];
  const id = obj.objectId;
  if (objectsCache[id] && objectsCache[id].measurements) {
    drawLightcurve(objectsCache[id].measurements);
    fillAnnotationFields(id);
    return;
  }
  try {
    showCanvasLoading(true);
    const adql = buildMeasurementsAdql(id);
    const raw = await postAdql(adql);
    const rows = parseTapJson(raw);
    const meas = rows.map(r => ({ mjd: Number(r.mjd), mag: Number(r.mag), magerr: Number(r.magerr), filter: r.filter }));
    objectsCache[id] = objectsCache[id] || {};
    objectsCache[id].measurements = meas;
    // try to keep annotations if existed in localStorage
    const saved = loadStorageObject(id);
    if (saved) objectsCache[id] = { ...objectsCache[id], ...saved };
    drawLightcurve(meas);
    fillAnnotationFields(id);
    renderCatalog();
  } catch(e) {
    alert('Błąd podczas pobierania pomiarów: ' + e.message);
    console.error(e);
  } finally { showCanvasLoading(false); }
}

/* ---------- Canvas drawing ---------- */
function showCanvasLoading(on){ const ctx = lcCanvas.getContext('2d'); if(on){ ctx.clearRect(0,0,lcCanvas.width,lcCanvas.height); ctx.fillStyle='#f8fafc'; ctx.fillRect(0,0,lcCanvas.width,lcCanvas.height); ctx.fillStyle='#6b7280'; ctx.fillText('Ładowanie...',10,20);} }
function drawLightcurve(meas){
  const dpr = window.devicePixelRatio || 1;
  lcCanvas.width = lcCanvas.clientWidth * dpr;
  lcCanvas.height = lcCanvas.clientHeight * dpr;
  const ctx = lcCanvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,lcCanvas.clientWidth,lcCanvas.clientHeight);
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,lcCanvas.clientWidth,lcCanvas.clientHeight);
  if (!meas || meas.length===0){ ctx.fillStyle='#6b7280'; ctx.fillText('Brak danych',10,20); return; }
  const margin = 36; const W = lcCanvas.clientWidth, H = lcCanvas.clientHeight; const w = W - margin*2, h = H - margin*2;
  const mjd = meas.map(m=>m.mjd); const mag = meas.map(m=>m.mag);
  const minM = Math.min(...mjd), maxM = Math.max(...mjd);
  const minMag = Math.min(...mag), maxMag = Math.max(...mag);
  function sx(x){ return margin + ((x - minM)/( (maxM - minM) || 1 ))*w; }
  function sy(y){ return margin + (1 - ((y - minMag)/( (maxMag - minMag) || 1 )) )*h; }
  ctx.strokeStyle = '#e6edf3'; ctx.beginPath(); ctx.moveTo(margin, margin); ctx.lineTo(margin, margin+h); ctx.lineTo(margin+w, margin+h); ctx.stroke();
  ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 1.5; ctx.beginPath();
  meas.forEach((pt,i)=>{ const x=sx(pt.mjd), y=sy(pt.mag); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
  ctx.stroke();
  ctx.fillStyle = '#1e40af'; meas.forEach(pt=>{ const x=sx(pt.mjd), y=sy(pt.mag); ctx.beginPath(); ctx.arc(x,y,2.6,0,Math.PI*2); ctx.fill(); });
  ctx.fillStyle = '#374151'; ctx.font='12px sans-serif'; ctx.fillText('MJD', W/2, H-8); ctx.fillText('mag (lower = brighter)', 6, 12);
}

/* ---------- Annotations, folders, storage ---------- */
function storageKey(){ return 'rubin_browser_v1'; }
function loadAllStorage(){ try { return JSON.parse(localStorage.getItem(storageKey()) || '{}'); } catch(e){ return {}; } }
function saveAllStorage(obj){ localStorage.setItem(storageKey(), JSON.stringify(obj)); }

function loadStorageObject(objectId){
  const all = loadAllStorage();
  return all.objects && all.objects[objectId] ? all.objects[objectId] : null;
}
function saveStorageObject(objectId, data){
  const all = loadAllStorage();
  all.objects = all.objects || {};
  all.objects[objectId] = { ...(all.objects[objectId] || {}), ...data };
  saveAllStorage(all);
}
function deleteStorageObjectFromFolder(objectId, folderName){
  const all = loadAllStorage();
  if (!all.folders || !all.folders[folderName]) return;
  all.folders[folderName] = all.folders[folderName].filter(id => id !== objectId);
  saveAllStorage(all);
}
function addObjectToFolder(objectId, folderName){
  const all = loadAllStorage();
  all.folders = all.folders || {};
  all.folders[folderName] = all.folders[folderName] || [];
  if (!all.folders[folderName].includes(objectId)) all.folders[folderName].push(objectId);
  saveAllStorage(all);
}

/* ---------- Render folders UI ---------- */
function renderFolders(){
  const container = document.getElementById('folders');
  container.innerHTML = '';
  const all = loadAllStorage();
  const folders = all.folders || {};
  for (const name of Object.keys(folders)){
    const div = document.createElement('div'); div.className='folder';
    const title = document.createElement('div'); title.textContent = name; title.style.fontWeight='600';
    const list = document.createElement('div'); list.style.marginTop='6px';
    folders[name].forEach(id => {
      const el = document.createElement('div'); el.style.display='flex'; el.style.justifyContent='space-between'; el.style.alignItems='center';
      el.textContent = id;
      const btn = document.createElement('button'); btn.textContent='Open'; btn.onclick = ()=>{
        // try to find object in current catalog, otherwise set currentIndex=-1 and fetch measurements
        const idx = catalog.findIndex(o=>o.objectId==id);
        if (idx>=0) openObject(idx);
        else {
          // insert temporary entry and open by direct fetch
          openObjectById(id);
        }
      };
      const rm = document.createElement('button'); rm.textContent='Remove'; rm.className='btn-ghost'; rm.onclick = ()=>{ deleteStorageObjectFromFolder(id,name); renderFolders(); };
      const wrap = document.createElement('div'); wrap.style.display='flex'; wrap.style.gap='6px'; wrap.appendChild(btn); wrap.appendChild(rm);
      el.appendChild(wrap);
      list.appendChild(el);
    });
    div.appendChild(title); div.appendChild(list);
    container.appendChild(div);
  }
}

/* ---------- Open object by id (direct fetch even jeśli nie w current catalog) ---------- */
async function openObjectById(objectId){
  try {
    showCanvasLoading(true);
    const adql = buildMeasurementsAdql(objectId);
    const raw = await postAdql(adql);
    const rows = parseTapJson(raw);
    const meas = rows.map(r => ({ mjd: Number(r.mjd), mag: Number(r.mag), magerr: Number(r.magerr), filter: r.filter }));
    objectsCache[objectId] = objectsCache[objectId] || {};
    objectsCache[objectId].measurements = meas;
    const saved = loadStorageObject(objectId);
    if (saved) objectsCache[objectId] = { ...objectsCache[objectId], ...saved };
    drawLightcurve(meas);
    fillAnnotationFields(objectId);
  } catch(e){
    alert('Błąd fetch by id: ' + e.message);
    console.error(e);
  } finally { showCanvasLoading(false); }
}

/* ---------- Fill annotation input fields for current object ---------- */
function fillAnnotationFields(objectId){
  const saved = loadStorageObject(objectId) || {};
  document.getElementById('name').value = saved.name || '';
  document.getElementById('category').value = saved.category || '';
  document.getElementById('note').value = saved.note || '';
}

/* ---------- Buttons actions ---------- */
document.getElementById('setProxy').addEventListener('click', ()=>{
  const url = document.getElementById('proxyUrl').value.trim();
  if (!url) return alert('Wpisz URL proxy');
  ADQL_POST_URL = url;
  alert('ADQL_POST_URL ustawione na: ' + ADQL_POST_URL + '\nPamiętaj: proxy musi przyjmować POST {adql:"..."} i wykonać do TAP /sync.');
});
document.getElementById('toggleUseProxy').addEventListener('click', ()=>{
  USE_PROXY = !USE_PROXY;
  document.getElementById('toggleUseProxy').textContent = 'Use proxy: ' + (USE_PROXY ? 'ON' : 'OFF');
});

document.getElementById('pageSize').addEventListener('change', (e)=>{ pageSize = Number(e.target.value) || 100; });
document.getElementById('offset').addEventListener('change', (e)=>{ offset = Number(e.target.value) || 0; });

document.getElementById('nextPage').addEventListener('click', ()=>{ offset += pageSize; document.getElementById('offset').value = offset; loadCatalogPage(); });
document.getElementById('prevPage').addEventListener('click', ()=>{ offset = Math.max(0, offset - pageSize); document.getElementById('offset').value = offset; loadCatalogPage(); });

document.getElementById('loadCatalog').addEventListener('click', ()=>{ offset = Number(document.getElementById('offset').value) || 0; loadCatalogPage(); });

async function loadCatalogPage(){
  // jeśli proxy OFF -> generujemy mock listę (demo). Jeśli ON -> pobieramy katalog z TAP.
  if (!USE_PROXY){
    // demo: utwórz pageSize sztuk mock obiektów
    catalog = [];
    for (let i=0;i<pageSize;i++){
      const id = 'MOCK_'+(offset + i + 1);
      const ra = 150 + (Math.random()-0.5)*10;
      const dec = 2 + (Math.random()-0.5)*4;
      catalog.push({ objectId: id, ra, dec });
    }
    renderCatalog();
    return;
  }
  try {
    const adql = buildCatalogAdql(pageSize, offset);
    const raw = await postAdql(adql);
    const rows = parseTapJson(raw);
    // rows expected to have objectId, ra, dec
    catalog = rows.map(r => ({ objectId: r.objectId ?? r.objid ?? r.id, ra: parseFloat(r.ra), dec: parseFloat(r.dec) }));
    renderCatalog();
  } catch(e){
    alert('Błąd pobierania katalogu: ' + e.message);
    console.error(e);
  }
}

/* ---------- Save annotation, folder management, PNG ---------- */
document.getElementById('saveAnnotation').addEventListener('click', ()=>{
  const obj = (currentIndex>=0 && currentIndex < catalog.length) ? catalog[currentIndex] : null;
  if (!obj) return alert('Brak otwartego obiektu z listy (lub otwórz obiekt przez folder).');
  const id = obj.objectId;
  const data = { name: document.getElementById('name').value, category: document.getElementById('category').value, note: document.getElementById('note').value };
  // save PNG if rendered
  try { const png = lcCanvas.toDataURL('image/png'); data.png = png; objectsCache[id] = objectsCache[id] || {}; objectsCache[id].png = png; } catch(e){}
  saveStorageObject(id, data);
  renderCatalog(); renderFolders();
  alert('Adnotacja zapisana lokalnie.');
});

document.getElementById('savePng').addEventListener('click', ()=>{
  const obj = (currentIndex>=0 && currentIndex < catalog.length) ? catalog[currentIndex] : null;
  if (!obj) return alert('Brak otwartego obiektu do zapisania PNG.');
  const id = obj.objectId; const png = lcCanvas.toDataURL('image/png');
  objectsCache[id] = objectsCache[id] || {}; objectsCache[id].png = png;
  saveStorageObject(id, { png });
  renderCatalog();
  alert('PNG zapisane lokalnie.');
});

document.getElementById('createFolder').addEventListener('click', ()=>{
  const name = document.getElementById('newFolderName').value.trim();
  if (!name) return alert('Podaj nazwę folderu');
  const all = loadAllStorage(); all.folders = all.folders || {}; if (!all.folders[name]) all.folders[name] = []; saveAllStorage(all); renderFolders();
});

document.getElementById('addToFolder').addEventListener('click', ()=>{
  const obj = (currentIndex>=0 && currentIndex < catalog.length) ? catalog[currentIndex] : null;
  if (!obj) return alert('Brak otwartego obiektu.');
  const name = prompt('Do którego folderu dodać? (dokładna nazwa)'); if (!name) return;
  addObjectToFolder(obj.objectId, name);
  renderFolders();
});

document.getElementById('removeFromFolder').addEventListener('click', ()=>{
  const obj = (currentIndex>=0 && currentIndex < catalog.length) ? catalog[currentIndex] : null;
  if (!obj) return alert('Brak otwartego obiektu.');
  const name = prompt('Z którego folderu usunąć? (dokładna nazwa)'); if (!name) return;
  deleteStorageObjectFromFolder(obj.objectId, name);
  renderFolders();
});

document.getElementById('nextObj').addEventListener('click', ()=>{ if (catalog.length===0) return; currentIndex = Math.min(catalog.length-1, (currentIndex<0?0:currentIndex+1)); openObject(currentIndex); });
document.getElementById('prevObj').addEventListener('click', ()=>{ if (catalog.length===0) return; currentIndex = Math.max(0, currentIndex-1); openObject(currentIndex); });

document.getElementById('exportCsv').addEventListener('click', ()=>{
  const all = loadAllStorage();
  const rows = [];
  const objs = all.objects || {};
  for (const id in objs){
    const o = objs[id];
    rows.push([id, o.name||'', o.category||'', (o.note||'').replace(/\\n/g,' '), o.png||''].map(v=>`"${(String(v||'')).replace(/"/g,'""')}"`).join(','));
  }
  const csv = ['objectId,name,category,note,png', ...rows].join('\\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='rubin_annotations.csv'; a.click(); URL.revokeObjectURL(url);
});

/* ---------- Initialization ---------- */
renderFolders();
pageSize = Number(document.getElementById('pageSize').value);
offset = Number(document.getElementById('offset').value);

window.setAdqlUrl = function(url){ ADQL_POST_URL = url; alert('ADQL_POST_URL ustawione: ' + ADQL_POST_URL); };
</script>
</body>
</html>
